---
---

# Oracles (Savers)

- Repo: gitlab.com/rarimo/savers/saver-grpc-lib
- Repo: gitlab.com/rarimo/savers/evm-saver-svc
- Repo: gitlab.com/rarimo/savers/solana-saver-svc
- Repo: gitlab.com/rarimo/savers/near-saver-svc

The saver services designed to be launched by validators in two supported modes:
- saver (connects to the chain rpc and submits new transfer operations to the Rarimo core)
- voter (fetches new operations from core, verifies the content and votes for its correctness)

Currently there are three implementations exists:
- evm-saver (used with any evm-compatible chains)
- solana-saver (used with any solana-compatible chains)
- near-saver (used with any near-compatible chains)

Every validator should run validator node (rarimo-core) and saver service in voter mode for every supported chain.
Saver mode can be also optionally launched.

## Logic

### Native and FT
For native and fungible tokens all information should be pre-defined in collections of `tokenmanager` module.
So oracles should only fetch the corresponding data and submit it in `MsgCreateTransferOp` transaction.

### NFT
NFT tokens collection can contain huge amount of tokens under it, and also they can be minted if future.
So we can not define all tokens in core during initialization or token add operation. That is why collections flow was created.
Using `tokenmanager` `Collection` and `CollectionData` we can define collection global and chain information regardless
of the number of tokens in collection or their metadata.
Token information (`Item` and `OnChainItem`) will be set up during the first token transfer.
During the first transfer oracles should fill the metadata field in `MsgCreateTransferOp` and provide all required token information to create `Item` and `OnChainItem`.

Token addresses are equal to the token collection addresses that is already defined in `Collection` but for token id we should provide more complicated implementation.
Let's describe the flow more accurately:

1. If token was already transferred between source and destination chain no additional actions required. Oracle just 
fetches `OnChainItem` from core and leaves metadata field empty.

2. If source `OnChainItem` exists but destination `OnChainItem` does no (it means that token never was transferred on destination chain)
oracle should construct destination `OnChainItem` using the following rules:
- if destination chain is Solana, tokenId should be derived using bridge address and seed from `Item` metadata (`Item` should exist cause `OnChainItem` exists)
- otherwise tokenId will be equal to the home chain tokenId (the chain where token was minted firstly).

3. If source `OnChainItem` does not exists it means that we are transferring token at first time and `Item` with its metadata also does not exist.
So oracle should create `Item` metadata what means fetching on-chain metadata and generation of solana seed. Then using paragraph 2 rules oracle constructs destination `OnChainItem`.
Source `OnChainItem, which is home `OnChainItem`, can be constructed using deposit event information.


## Library

In `gitlab.com/rarimo/savers/saver-grpc-lib` we defined the common utils for all oracles.
Every oracle should implement `verifiers.TransferOperator` interface for every supported token type
and put that implementations into the `voter.Subscriber` and `voter.Catchupper` using `verifiers.TransferVerifier` wrapper.

Also, we recommend to split `verifiers.TransferOperator` logic in two methods: verifier and message creator.
It allows to use message creator while fetching new events and submitting them into core.