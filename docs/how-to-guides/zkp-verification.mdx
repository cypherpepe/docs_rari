# How to Verify a Zero-Knowledge Proof in a Smart Contract

## On-chain verification flow
![On-chain verification flow](/img/zkp-verification.png)

At its core, every on-chain interactions between a Verifier and the Prover (usually a user's Wallet) follows this workflow:
1. After having deployed a Verifier Smart Contract, the Verifier designs a Request for the users (usually used to check certain fields in the Iden3 claims). This has to be recorded on-chain inside the Verifier Smart Contract (via ```setZKPRequest``` function).
1. Verifier DApp presents the Request to the user
1. The user parses the request and generates a ZKP according to the request.
1. The user sends the ZKP to the Verifier Smart Contract.
1. The Verifier Smart Contract verifies the ZKP.
1. If the verification is successful, the Verifier executes the logic defined in the Smart Contract.

An active action from the Verifier is only required at step 1. All the rest of the interaction is between the user and the Smart Contract.

## Integrating a ZK Verifier Into Your Smart Contract

Let's start by integrating ZKVerifier into the Smart Contract.
Assume, that we have a default `ERC20` contract.
We will add not a very useful restriction, but still â€” the mint can be done, only if user provided a proof that he was born before the `01/01/2000`.

The default contract looks like this (all necessary files can be found here <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20" target="_blank" rel="noreferrer noopener">OpenZeppelin GitHub</a>):


```
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract ERC20 is IERC20 {
    uint public totalSupply;
    mapping(address => uint) public balanceOf;
    mapping(address => mapping(address => uint)) public allowance;
    string public name = "ExampleToken";
    string public symbol = "EXTRRM";
    uint8 public decimals = 18;

    function transfer(address recipient, uint amount) external returns (bool) {
        balanceOf[msg.sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    function approve(address spender, uint amount) external returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    function transferFrom(
        address sender,
        address recipient,
        uint amount
    ) external returns (bool) {
        allowance[sender][msg.sender] -= amount;
        balanceOf[sender] -= amount;
        balanceOf[recipient] += amount;
        emit Transfer(sender, recipient, amount);
        return true;
    }

    // We want the mint function to be executed only if the valid proof was provided
    function mint(uint amount) external {
        balanceOf[msg.sender] += amount;
        totalSupply += amount;
        emit Transfer(address(0), msg.sender, amount);
    }

    function burn(uint amount) external {
        balanceOf[msg.sender] -= amount;
        totalSupply -= amount;
        emit Transfer(msg.sender, address(0), amount);
    }
}
```

As being said, the restriction would be `to be born before 01/01/2000`.
Here is the example of Verifiable Credentials, and we want to check the `birthday` field here:

```json
  {
    "id": "8edd8112-c415-11ed-b036-debe37e1cbd6",
    "proofTypes": [
      "BJJSignature2021"
    ],
    "createdAt": "2023-03-20T11:54:01.110295+01:00",
    "expiresAt": "2025-03-20T11:54:01.110295+01:00",
    "expired": false,
    "schemaHash": "c9b2370371b7fa8b3dab2a5ba81b6838",
    "schemaType": "KYCAgeCredential",
    "schemaUrl": "https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json/KYCAgeCredential-v3.json",
    "revoked": false,
    "revNonce": 2136005230,
    "credentialSubject": {
      "birthday": 19960424,
      "documentType": 2,
      "id": "did:polygonid:polygon:mumbai:2qDDDKmo436EZGCBAvkqZjADYoNRJszkG7UymZeCHQ"
    },
    "userID": "did:polygonid:polygon:mumbai:2qFpPHotk6oyaX1fcrpQFT4BMnmg8YszUwxYtaoGoe"
  }
```

We will work with the iden3 contracts (which are used in Rarimo), mainly with `ZKPVerifier` and all contracts that are imported in it (i.e. `ICircuitValidator`, `ArrayUtils`, etc).
All the files can be found here: <a href="https://github.com/iden3/contracts" target="_blank" rel="noreferrer noopener">Iden3 GitHub</a>.

The ZKPVerifier Contract provides 2 hooks: ```_beforeProofSubmit``` and ```_afterProofSubmit```.
These hooks are called before and after any proof gets submitted and can be used to create certain logic inside your Smart Contract.
Our ERC20Verifier contract must define at least a single `TRANSFER_REQUEST_ID`.
This is the Identifier of the request that the contract is posing to the user.

To enable ZK Verification, we should add the following lines to our contract, namely two hooks with the logic, which you can change:

```
pragma solidity ^0.8.16;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./lib/GenesisUtils.sol";
import "./interfaces/ICircuitValidator.sol";
import "./verifiers/ZKPVerifier.sol";

contract ERC20Verifier is IERC20, ZKPVerifier {

    mapping(address => uint256) public addressToId;

    uint64 public constant TRANSFER_REQUEST_ID = 1;
    uint64 public constant TOKENS_TO_MINT = 100;

    function _beforeProofSubmit(
        uint64, /* requestId */
        uint256[] memory inputs,
        ICircuitValidator validator
    ) internal view override {
        // your custom logic can be implemented here

        // checks that the challenge input of the proof is equal to the msg.sender
        address addr = GenesisUtils.int256ToAddress(
            inputs[validator.getInputOf("challenge")]
        );
        require(
            msg.sender == addr,
            "sender address is not an address in the proof"
        );
    }

    function _afterProofSubmit(
        uint64 requestId,
        uint256[] memory inputs,
        ICircuitValidator validator
    ) internal override {
        // your custom logic can be implemented here

        // checks that proof was submitted only once by one user
        require(
            requestId == TRANSFER_REQUEST_ID && addressToId[msg.sender] == 0,
            "proof can not be submitted more than once"
        );

        uint256 id = inputs[validator.getInputOf("challenge")];

        // mint tokens
        addressToId[msg.sender] = id;
        super._mint(msg.sender, TOKENS_TO_MINT);
    }

    // all other ERC20 functions should be included too
}
```

## Set the ZKP Request

After that being done and the contract has been deployed, we should design a Request for our users through the `setZKPRequest` function.

To do that, we must provide 6 inputs to the `setZKPRequest` function:

1. `requestID`: the ID associated with the request (`1` in our contract).
1. `validator`: the address of the `Validator Smart Contract`. It's type can be either `CredentialAtomicQuerySigValidator` or `CredentialAtomicQueryMTPValidator` depending on how the credentials were issued.
1. `schema`: the bigInt representation of the schema of the requested credential.
1. `claimPathKey`: represents the path to the queries key inside the merklized credential (In our case it is the path to the `birthday` key).
1. `operator`: is either 1, 2, 3, 4, 5 or 6 (`less-than` operator, that we need is `2`).
1. `value`: represents the threshold value you are querying (01/01/2000 date in our case).

You can run https://go.dev/play/p/rnrRbxXTRY6 to get schema hash and claimPathKey using your schema.

This is how the example request would look like:

```json
{
    "id": "7f38a193-0918-4a48-9fac-36adfdb8b542",
    "typ": "application/iden3comm-plain-json",
    "type": "https://iden3-communication.io/proofs/1.0/contract-invoke-request",
    "thid": "7f38a193-0918-4a48-9fac-36adfdb8b542",
    "body": {
        "reason": <The reason why the proof is being asked, e.g. "airdrop participation">,
        "transaction_data": {
            "contract_address": "<YourVerifierAddress>",
            "method_id": "b68967e2",
            "chain_id": <chain_id where your contract has been deployed, e.g. 80001>,
            "network": <the name of the network, where your the contract has been deployed, e.g. "polygon-mumbai">
        },
        "scope": [
            {
                "id": 2,
                "circuitId": "credentialAtomicQuerySigV2OnChain",
                "query": {
                    "allowedIssuers": [
                        "*"
                    ],
                    "context": "https://raw.githubusercontent.com/iden3/claim-schema-vocab/main/schemas/json-ld/kyc-v3.json-ld",
                    "credentialSubject": {
                        "birthday": {
                            "$lt": 20000101
                        }
                    },
                    "type": "KYCAgeCredential"
                }
            }
        ]
    }
}
```

Finally, to check that everything works as expected, you should generate the proof, using your schema (and VC) and provide it to your Verifier contract. As a result, you should receive 100 minted tokens at your address.