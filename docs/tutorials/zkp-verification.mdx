---
sidebar_label: On-chain ZKP Verification
---
# How to Verify a Zero-Knowledge Proof in a Smart contract

## On-chain verification of a Zero-Knowledge Proof

Smart contracts allow systems to verify certain data and based on the result provide certain features or execute other functions. Zero-Knowledge Proof cryptography allows to verify the same data, but in a private manner (without revealing any personal information of the prover).

Such flow is needed when further on-chain logic wants to be implemented on successful verification, such as:
* Distribute a token-airdrop only to human-verified accounts
* Allow voing only to account members of a DAO
* Allow to send funds only to (or by) accounts that passed the KYC verification

## On-chain verification flow (abstract)
![On-chain verification flow](/img/zkp-verification.png)

At its core, every on-chain interactions between a Verifier and the Prover (usually a user's Wallet) follows this workflow:
1. After having deployed a Verifier Smart Contract, the Verifier designs a Request for the users (usually used to check certain fields in the Iden3 claims). This has to be recorded on-chain inside the Verifier Samrt Contract (via ```setZKPRequest``` function).
1. The Request is delivered to the user (it is up to the implementer, can be done through the QR code or via deep-linking).
1. The user parses the request and generates a zk proof according to the request.
1. The user sends the zk proof to the Verifier Smart Contract.
1. The Verifier Smart Contract verifies the zk Proof.
1. If the verification is successful, the Verifier executes the logic defined in the Smart Contract.

An active action from the Verifier is only required at step 1. All the rest of the interaction is between the user and the Smart Contract.

## Create a simple ZK Verifier

In this tutorial we will create a really simple contract, that will send all the funds from the contract to the user, that provides a valid proof. 


```
pragma solidity ^0.8.16;


import "./lib/GenesisUtils.sol";
import "./interfaces/ICircuitValidator.sol";
import "./verifiers/ZKPVerifier.sol";

contract PreImageLottery is ZKPVerifier {
    // any user can fund this contract
    function fund() payable public { }

}
```

The ZKPVerifier Contract provides 2 hooks: ```_beforeProofSubmit``` and ```_afterProofSubmit```.
These hooks are called before and after any proof gets submitted and can be used to create certain logic inside your Smart Contract.

We will simply make that contract sends all the money to the prover after he provides a valid proof (```_afterProofSubmit```).
We do not specify what is stated in the proof. 
It can be knowledge of some pre-image `x` of a hash function or something more complicated, which is up to implementer.

The code is available below:

```
pragma solidity ^0.8.16;

import "./lib/GenesisUtils.sol";
import "./interfaces/ICircuitValidator.sol";
import "./verifiers/ZKPVerifier.sol";

contract PreImageLottery is ZKPVerifier {
    // any user can fund this contract
    function fund() payable public returns (bool success) { }

    function _beforeProofSubmit(
        uint64, /* requestId */
        uint256[] memory inputs,
        ICircuitValidator validator
    ) internal view override {
       // your "before proof is submitted" logic can be implemented here
    }

    function _afterProofSubmit(
        uint64 requestId,
        uint256[] memory inputs,
        ICircuitValidator validator
    ) internal override {
        
        payable(msg.sender).transfer(address(this).balance);
    }
}

```
