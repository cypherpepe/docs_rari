---
---

# Proof of Humanity SBT

To make the Proof of Humanity verification result easily re-usable and to enable easy integration with existing DApps like quest platforms, each verified user gets a soulbound token(SBT).

This is facilitated by `VerifiedSBT` and `SBTIdentityVerifier` contracts.

<!-- TODO: add SBT entanglement -->

## `VerifiedSBT`

The Proof of Humanity SBT  smart contract.

```solidity
contract VerifiedSBT is
    IVerifiedSBT,
    UUPSUpgradeable,
    ERC721EnumerableUpgradeable,
    OwnableUpgradeable
{
    // ...

    address public override verifier;
    uint256 public override nextTokenId;
    string public override tokensURI;

    modifier onlyVerifier() {
        require(msg.sender == verifier, "VerifiedSBT: only verifier can call this function");
        _;
    }

    function mint(address recipientAddr_) external override onlyVerifier {
        _mint(recipientAddr_, nextTokenId++);
    }

    // ...
}
```

- `verifier` - address of the verifier's (SBTIdentityVerifier) contract;
- `nextTokenId` - nonce that is incremented each time a new SBT is created;
- `tokensURI` - token's picture URI;
- `onlyVerifier()` - a special modifier, so most functions can be called only by the verifier contract;
- `mint(address)` - mints the SBT for the given address;

Full implementation can be found [here](https://gitlab.com/rarimo/identity/contracts/-/blob/master/contracts/tokens/VerifiedSBT.sol?ref_type=heads).

## `SBTIdentityVerifier`

It's an implementation of a verifier contract that mints a Proof of Humanity SBT when a correct proof is provided.

```solidity
contract SBTIdentityVerifier is ISBTIdentityVerifier, BaseVerifier {
    function _proveIdentity(ProveIdentityParams calldata proveIdentityParams_) internal {
        _verify(SBT_IDENTITY_PROOF_QUERY_ID, proveIdentityParams_);

        require(
            addressToIdentityId[msg.sender] == 0,
            "IdentityVerifier: Msg sender address has already been used to prove the another identity."
        );

        IQueryValidator queryValidator_ = IQueryValidator(
            zkpQueriesStorage.getQueryValidator(SBT_IDENTITY_PROOF_QUERY_ID)
        );

        uint256 identityId_ = proveIdentityParams_.inputs[queryValidator_.getUserIdIndex()];

        require(
            !isIdentityProved(identityId_),
            "IdentityVerifier: Identity has already been proven."
        );

        uint256 newTokenId_ = sbtToken.nextTokenId();
        sbtToken.mint(msg.sender);

        addressToIdentityId[msg.sender] = identityId_;
        _identitiesProofInfo[identityId_] = SBTIdentityProofInfo(msg.sender, newTokenId_, true);

        emit SBTIdentityProved(identityId_, msg.sender, address(sbtToken), newTokenId_);
    }
}
```

- `_proveIdentity(...)` checks the validity for a ZKP and mints an SBT;

Full implementation can be found [here](https://gitlab.com/rarimo/identity/contracts/-/blob/master/contracts/verifiers/SBTIdentityVerifier.sol?ref_type=heads).
