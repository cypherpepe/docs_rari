---
---

# Identity Protocol contracts

While Rarimo inherits a lot of identity contracts from iden3 with minor changes, it also has features, such as `LightweightState` contract.
We will firstly describe the `State` contract (the one, inherited from the iden3) and changes that were done to it and then will move to `LightweightState` contract.
Finally, verifiers contracts will be explained.

## State contract
The changes (the only one) will be described firstly, and then the contract itself.
If you're familiar with the Iden3 protocol, you can skip the contract's description section and read only the .

### Rarimo's changes to the contract
The only thing that were added is the `StateTransited` event, that is important for Rarimo oracles. 

```Solidity
event StateTransited(
        uint256 gistRoot,
        uint256 indexed id,
        uint256 state,
        uint256 timestamp,
        uint256 blockNumber
    );
```
It is emitted every time in `transitState` function and provides the following information:
- `gistRoot` - global identity state tree root after the transition.
- `id` - identity, which called the function
- `state` - new state of the identity
- `timestamp` - block timestamp of this block
- `blockNumber` - block number (height) of this block

Oracles needed this information, to know who made the transition, it's new state, when (timestamp, height) and so on, so the event was added.

### State contract

As being said, the rest of the contract is the exact copy of [iden3](https://docs.iden3.io/contracts/state/) state contract.

```Solidity
/* ... */
IStateTransitionVerifier internal verifier;
StateLib.Data internal _stateData;
SmtLib.Data internal _gistData;

function transitState(
        uint256 id_,
        uint256 oldState_,
        uint256 newState_,
        bool isOldStateGenesis_,
        uint256[2] memory a_,
        uint256[2][2] memory b_,
        uint256[2] memory c_
    ) external
/* ... */
```

- `verifier` - address of the state transition verifier contract. It verifies the state transition ZKP.
- `_stateData` - struct for storing all the state data. Contains a mapping of state history per each identity and state metadata of each state.
- `_gistData` - struct for storing all gist data. Contains all the nodes in the tree and all roots history with timestamps and heights.
- `transitState` - the main function of the contract, that performs state transition.
It receives the identity, two states (old and new), boolean whether it is genesis or not and ZK Proof, that proves that state transition from old to new state of this identity is valid and fair. 
- other minor functions, such as `getGISTRoot()` (returns latest GIST root) are not described, but all the contracts can be found [here](https://gitlab.com/rarimo/identity/contracts/-/tree/master/contracts).
For more information about state contract we refer to [iden3 documentation](https://docs.iden3.io/contracts/state/).


### LightweightState contract

This contract is used on destination chains, that want to receive state data from the Rarimo.
Once it is deployed, the state from source chain (Rarimo) can be transferred to destination chain (assume Ethereum) via ECDSA Threshold signature.
It is done by the user (i.e. he can request such an action) if state transition is required at the destination chain.

The contract and it's core elements:
```
/* ... */
    address public override sourceStateContract;
    string public override sourceChainName;
    bytes32 public override identitiesStatesRoot;
    uint256 internal _currentGistRoot;
    mapping(uint256 => GistRootData) internal _gistsRootData;
    mapping(bytes32 => IdentitiesStatesRootData) internal _identitiesStatesRootsData;

    function signedTransitState(
        bytes32 newIdentitiesStatesRoot_,
        GistRootData calldata gistData_,
        bytes calldata proof_
    ) external override { 
        /* ... */
    }

/* ... */
```

- `sourceStateContract` - address of the contract on source chain (Rarimo in our case)
- `sourceChainName` - the chain, where the source contract is deployed (Rarimo)
- `identitiesStatesRoot` - another tree root (made specially for Lightweight contract), that stores issuer id, it's state and timestamp of state change (gist doesn't have timestamps).
- `_currentGistRoot` - current root of the gist
- `_gistsRootData` - history of gist roots with timestamps
- `_identitiesStatesRootsData` - history of identities states rooots with timestamps
- `signedTransitState()` - state transition function, that requires TSS instead of ZKP. 
It verifies the signature and changes the roots to the ones provided.
After that, user can provide proofs using the new root on destination chain.
Inputs are:
  - `newIdentitiesStatesRoot_` - new identities states root
  - `gistData_` - new gist root and it's timestamp
  - `proof_` - ECDSA threshold signature

## Verifier contracts

Verifier contracts main purpose is to verify ZK proof and then execute business logic, that is specific for certain dApp.
Rarimo has 3 types of verifier contracts: `BaseVerifier`, `IdentityVerifier` and `SBTIdentityVerifier`.
The last one will be described in another page.

### BaseVerifier contract

`BaseVerifier` is an abstract contract, that you can inherit and add your custom business logic.
It implements some of the core functions:

```Solidity
abstract contract BaseVerifier is IBaseVerifier, OwnableUpgradeable, UUPSUpgradeable {
    /* ... */

 function _transitState(TransitStateParams calldata transitStateParams_) internal {
        ILightweightState lightweightState_ = zkpQueriesStorage.lightweightState();
        ILightweightState.GistRootData memory currentGISTRootData_ = lightweightState_
            .getCurrentGISTRootInfo();

        if (
            !lightweightState_.isIdentitiesStatesRootExists(
                transitStateParams_.newIdentitiesStatesRoot
            ) &&
            currentGISTRootData_.createdAtTimestamp <
            transitStateParams_.gistData.createdAtTimestamp
        ) {
            lightweightState_.signedTransitState(
                transitStateParams_.newIdentitiesStatesRoot,
                transitStateParams_.gistData,
                transitStateParams_.proof
            );
        }
    }

    function _verify(
        string memory queryId_,
        ProveIdentityParams calldata proveIdentityParams_
    ) internal view virtual {
        require(
            zkpQueriesStorage.isQueryExists(queryId_),
            "BaseVerifier: ZKP Query does not exist for passed query id."
        );

        IQueryValidator queryValidator_ = IQueryValidator(
            zkpQueriesStorage.getQueryValidator(queryId_)
        );
        uint256 queryHash_ = zkpQueriesStorage.getStoredQueryHash(queryId_);

        queryValidator_.verify(
            proveIdentityParams_.statesMerkleData,
            proveIdentityParams_.inputs,
            proveIdentityParams_.a,
            proveIdentityParams_.b,
            proveIdentityParams_.c,
            queryHash_
        );

        _checkAllowedIssuer(queryId_, proveIdentityParams_.statesMerkleData.issuerId);
        _checkChallenge(proveIdentityParams_.inputs[queryValidator_.getChallengeInputIndex()]);
    }

    /* ... */

}
```
This contract uses `zkpQueriesStorage` contract, to store query ids and `lightweightState` contract address.
- `_transitState(TransitStateParams calldata transitStateParams_)` - calls the `lightweightState` contract from `zkpQueriesStorage` and transfers the state.
- `_verify(string memory queryId_, ProveIdentityParams calldata proveIdentityParams_)` - verifies the proof, using the `QueryValidator` for stated `queryId_`

Using both functions, you can implement your custom business logic and only verified identity will be able to use it.
It is also possible to restrict certain issuers, i.e. credentials from them can't be proven, because they are not in allowed list.


### IdentityVerifier contract

`IdentityVerifier` inherits `BaseVerifier` and binds the address to identity after the verification

```Solidity
contract IdentityVerifier is IIdentityVerifier, BaseVerifier {
    /* ... */

    mapping(address => uint256) public override addressToIdentityId;

    mapping(uint256 => IdentityProofInfo) internal _identitiesProofInfo;

    function _proveIdentity(ProveIdentityParams calldata proveIdentityParams_) internal {
        _verify(IDENTITY_PROOF_QUERY_ID, proveIdentityParams_);

        require(
            addressToIdentityId[msg.sender] == 0,
            "IdentityVerifier: Msg sender address has already been used to prove the another identity."
        );

        IQueryValidator queryValidator_ = IQueryValidator(
            zkpQueriesStorage.getQueryValidator(IDENTITY_PROOF_QUERY_ID)
        );

        uint256 identityId_ = proveIdentityParams_.inputs[queryValidator_.getUserIdIndex()];

        require(
            !isIdentityProved(identityId_),
            "IdentityVerifier: Identity has already been proven."
        );

        addressToIdentityId[msg.sender] = identityId_;
        _identitiesProofInfo[identityId_] = IdentityProofInfo(msg.sender, true);

        emit IdentityProved(identityId_, msg.sender);
    }

    /* ... */

}
```

- `addressToIdentityId` - mapping of address to identity identifier
- `_identitiesProofInfo` - mapping of identity to the struct, that stores address and boolean (whether the identity isProven or not)
- `_proveIdentity(ProveIdentityParams calldata proveIdentityParams_)` - verifies the proof and stores the info in mentioned mappings.