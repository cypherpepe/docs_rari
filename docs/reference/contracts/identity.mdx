---
---

# Identity Protocol Contracts

Rarimo builds upon the basic [Iden3 smart contracts](https://github.com/iden3/contracts) and adapts them for cross-chain usage.

> Currently, identity smart contracts are available only for EVM-compatible chains.

Identity protocol uses two types of smart contracts:

- State Contracts hold iden3 identity states(sparse Merkle trees) that are required for on-chain ZKP verifications;
- Verifiers are responsible for verifying zero-knowledge proofs on-chain. They fetch identity states for the State Contracts to check that the credential used to generate the proof wasn't revoked by the issuer;

##  State Contracts

Rarimo uses two types of state contracts:

- `StateV2` holds the complete history of identity states. A single instance is deployed to the Rarimo chain and acts as a single source of truth;
- `LightweightState` implements the state contract interface but doesn't hold the entire history. The identity states are updated on demand and are secured by a threshold signature from Rarimo's oracles. One instance of this contract is deployed to every supported target chain;

### `StateV2`

Full implementation can be found [here](https://gitlab.com/rarimo/identity/contracts/-/blob/master/contracts/State.sol?ref_type=heads).

The primary contract interface:

```solidity
function transitState(
        uint256 id_,
        uint256 oldState_,
        uint256 newState_,
        bool isOldStateGenesis_,
        uint256[2] memory a_,
        uint256[2][2] memory b_,
        uint256[2] memory c_
) external

event StateTransited(
        uint256 gistRoot,        // global identity state tree root after the transition.
        uint256 indexed id,     // identity which called the function
        uint256 state,              // new state of the identity
        uint256 timestamp,     // block timestamp of this block
        uint256 blockNumber // height of this block
 );
```

- `transitState` - the primary function of the contract that performs state transitions. It receives the identity, two states (old and new), a boolean whether it is genesis or not, and ZK Proof, which proves that the state transition from old to new state of this identity is valid and fair;
- `StateTransited` - Emited after every state transition. Rarimo's oracles use it to ingest the state transitions;

### `LightweightState`

Full implementation can be found [here](https://gitlab.com/rarimo/identity/contracts/-/blob/master/contracts/LightweightState.sol?ref_type=heads).

The primary contract interface:

```
/* ... */
    address public override sourceStateContract;
    string public override sourceChainName;
    bytes32 public override identitiesStatesRoot;

    function signedTransitState(
        bytes32 newIdentitiesStatesRoot_,
        GistRootData calldata gistData_,
        bytes calldata proof_ // TSS from Rarimo's oracles
    ) external override {
        /* ... */
    }

```

- `sourceStateContract` - address of the contract on the source chain (Rarimo in our case)
- `sourceChainName` - the chain where the source contract is deployed (Rarimo)
- `identitiesStatesRoot` - another tree root (made specifically for the Lightweight contract) that stores the issuer ID, its state, and timestamp of state change (gist doesn't have timestamps).
- `signedTransitState()` - state transition function that requires TSS instead of ZKP. It verifies the signature and changes the roots to the ones provided. After that, the user can submit a ZKP using the new root on the destination chain.

## Verifier contracts

Verifier contracts' main purpose is to verify ZK proof and then execute business logic that is specific for certain DApp.
Rarimo has two types of verifier contracts: `BaseVerifier` and `IdentityVerifier'.

### `BaseVerifier`

Full implementation can be found [here](https://gitlab.com/rarimo/identity/contracts/-/blob/master/contracts/verifiers/BaseVerifier.sol?ref_type=heads).

`BaseVerifier` is an abstract contract that you can inherit and add your custom business logic.

It implements some of the core functions:

```solidity
abstract contract BaseVerifier is IBaseVerifier, OwnableUpgradeable, UUPSUpgradeable {
    /* ... */

 function _transitState(TransitStateParams calldata transitStateParams_) internal {
     	// ...
    }

    function _verify(
        string memory queryId_,
        ProveIdentityParams calldata proveIdentityParams_
    ) internal view virtual {
        // ...
    }

    /* ... */

}
```

This contract uses the `zkpQueriesStorage` contract to store query IDs and the `lightweightState` contract's address.

- `_transitState(TransitStateParams calldata transitStateParams_)` - calls the `lightweightState` contract from `zkpQueriesStorage` and transfers the state.
- `_verify(string memory queryId_, ProveIdentityParams calldata proveIdentityParams_)` - verifies the proof, using the `QueryValidator` for stated `queryId_`

Using both functions, you can implement your custom business logic and only verified identity can use it. It is also possible to restrict certain issuers, i.e., credentials from them can't be proven because they are not on the allowed list.

### `IdentityVerifier`

Full implementation can be found [here](
https://gitlab.com/rarimo/identity/contracts/-/blob/master/contracts/verifiers/IdentityVerifier.sol?ref_type=heads)

`IdentityVerifier` inherits `BaseVerifier` and binds the address to identity after the verification.

```solidity
contract IdentityVerifier is IIdentityVerifier, BaseVerifier {
    /* ... */

    mapping(address => uint256) public override addressToIdentityId;

    mapping(uint256 => IdentityProofInfo) internal _identitiesProofInfo;

    function _proveIdentity(ProveIdentityParams calldata proveIdentityParams_) internal {
	// ...
        emit IdentityProved(identityId_, msg.sender);
    }
}
```

- `addressToIdentityId` - mapping of address to identity identifier;
- `_identitiesProofInfo` - mapping of identity to the struct that stores address and boolean (whether the identity is proven or not);
- `_proveIdentity(ProveIdentityParams calldata proveIdentityParams_)` - verifies the proof and stores the info in mentioned mappings and emits an `IdentityProved` event that contains the user's ID and address;
