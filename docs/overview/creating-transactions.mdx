---
---

# Creating NFT checkout transactions

The easiest way to create Rarimo transactions is with the JavaScript/TypeScript SDK.
See the following sections:

- [Creating NFT checkout transactions in JavaScript/TypeScript applications](#javascript)
- [Creating NFT checkout transactions with React components](#react-applications)

## Examples

This example shows how to create a transaction in a React application: [transaction-react](https://github.com/rarimo/js-sdk-examples/tree/main/transaction-react).

## Creating NFT checkout transactions in JavaScript/TypeScript applications {#javascript}

The [@rarimo/nft-checkout](https://www.npmjs.com/package/@rarimo/nft-checkout) package provides tools that create cross-chain transactions with on the Rarimo protocol.

Sending a transaction with the SDK includes these main steps:

1. Connect to the wallet with the `createProvider()` function, which creates a wallet provider that represents the wallet.
1. Use the `createCheckoutOperation()` function to create an object that implements the `INFTCheckoutOperation` interface.
This object represents the transaction operation and provides methods to access a specific type of chain, estimate the transaction price, and complete the checkout process.
1. Bundle the data for the contracts to call as part of the transaction.
1. Run the transaction operation's `checkout()` method, which starts the transaction.

Here is an example of creating a transaction on the Goerli test chain:

```ts
import { createCheckoutOperation, EVMOperation, ChainNames } from '@rarimo/nft-checkout'
import { createProvider } from '@rarimo/provider'
import { MetamaskProvider } from '@rarimo/providers-evm'
import { utils } from "ethers";

// Address of the NFT sale contract
const NFT_CONTRACT_ADDRESS = "0x77fedfb705c8bac2e03aad2ad8a8fe83e3e20fa1"

const sendTransaction = async () => {
  // Connect to the Metamask wallet in the browser using Web3.js, using the MetamaskProvider interface to limit bundle size.
  const provider = await createProvider(MetamaskProvider)

  // Initialize the object that represents the transaction operation, in this case on EVM.
  const op = createCheckoutOperation(EVMOperation, provider)

  // Get the chains that are supported from that chain type.
  const chains = await op.supportedChains()

  // Select the chain to pay from.
  // This example uses the Goerli chain, but your application can ask the user which chain to use.
  const selectedChain = chains.find(i => i.name === ChainNames.Goerli)

  // Select the chain to pay on.
  // In this case, the NFT contract is on the Sepolia chain.
  const destinationChain = chains.find(i => i.name === ChainNames.Sepolia)

  // Set the parameters for the transaction, including the price and the tokens to accept payment in.
  const target = {
    // Destination chain id
    chainId: destinationChain!.id,
    // Recipient's wallet address
    recipient: "0x8fe0d4923f61ff466430f63471e27b89a7cf0c92",
    price: {
      // Price amount as an unsigned integer in a string
      value: "10000000000000000",
      // Number of decimals in the currency; in this case 18 for wei
      decimals: 18,
      // Price token symbol
      symbol: "ETH",
      // Results in a price of 10000000000000000/10^18, or 0.01 ETH
    },
    // The token to swap the payment token to
    swapTargetTokenSymbol: "WETH",
  }

  // Initialize the operation with the source chain and transaction parameters.
  await op.init({
    chainIdFrom: selectedChain!.id,
    target,
  })

  // Load the user's balance of payment tokens on the source chain.
  // When this method runs, the wallet prompts the user to switch to the selected chain if necessary.
  // Then, the method returns the tokens on this chain that the DEX supports and that the wallet has a balance of greater than zero.
  const tokens = await op.loadPaymentTokens(selectedChain!)

  // Select the token to accept payment in on the source chain.
  // This example hard-codes UNI, but your application can ask the user which token to pay with.
  const paymentToken = tokens[0]

  // Get the estimated purchase price in the payment token, including the cost to swap the tokens to the tokens that the seller accepts payment in.
  // At this point you can ask the user to confirm the transaction with the fees or cancel it.
  const estimatedPrice = await op.estimatePrice(paymentToken)

  // Create the transaction bundle, which includes custom logic that tells the Rarimo contract what to do after unlocking the transferred tokens on the destination chain, such as calling another contract to buy the NFT on the destination chain.
  // Optionally, you can set the bundle salt to be able to access the temporary contracts that Rarimo uses to run the bundled transactions.
  // See "Bundling" in the Rarimo documentation.

  // First, use the Ethers Interface to encode a command to add to the bundle.
  // This example encodes a command that purchases the NFT on the destination chain via the NFT contract's Application Binary Interface (ABI).
  // You can include other custom logic in the bundle.
  const encodedFunctionData = new utils
    .Interface(["function buy(address receiver_) payable"])
    .encodeFunctionData("buy", [
      target.recipient,
    ])

  // Then, create a bundle and add the purchase function.
  // The first parameter is the Solidity types of the values in the second parameter.
  // These parameters and their types are:
  // 1) The address of the contract that Rarimo will call to buy the NFT (`address[]`)
  // 2) The price of the NFT on the destination chain (`uint256[]`)
  // 3) The encoded purchase function (`bytes[]`)
  const bundle = utils.defaultAbiCoder.encode(
      ["address[]", "uint256[]", "bytes[]"],
      [
        [NFT_CONTRACT_ADDRESS],
        [target.price.value],
        [encodedFunctionData],
      ]
  );

  // Call the asynchronous checkout method to run the transaction.
  // The `checkout()` method takes the parameters from the operation instance, gets approval from the user's wallet, and calls the Rarimo contract to handle the transaction.
  const txHash = await op.checkout(estimatedPrice, { bundle })

  // Get the transaction on the source chain
  const sourceTxUrl = provider.getTxUrl(selectedChain!, String(txHash))
  console.log("Source chain transaction:", sourceTxUrl)

  // Get the transaction that unlocks tokens on the destination chain
  const destinationTx = await op.getDestinationTx(selectedChain!, String(txHash))
  const destinationTxUrl = provider.getTxUrl(selectedChain!, destinationTx.hash)
  console.log("Destination chain transaction:", destinationTxUrl)
}
```

## Creating NFT checkout transactions with React components {#react-applications}

The [@rarimo/react-nft-checkout](https://www.npmjs.com/package/@rarimo/react-nft-checkout) package provides React components that you can use in your UI to create cross-chain transactions with the Rarimo protocol.

To create a transaction with the React components, follow these general steps:

1. Create an object of the [Target](https://rarimo.github.io/js-sdk/types/_rarimo_nft_checkout.Target.html) type that represents the final NFT transaction, including the address of the NFT contract, the recipient or buyer's wallet address, and the price:

   ```tsx
   import { Price, Target } from "@rarimo/nft-checkout"

   // Set the price as 0.1 ETH and convert to gwei
   const priceOfNft = Price.fromRaw("0.01", 18, "ETH")

   const targetNft: Target = {
     // Source chain id (Sepolia in this case)
     chainId: 11155111,
     // Recipient wallet address
     recipient: "0x0000000000000000000000000000000000000000",
     price: priceOfNft,
     // The token to swap the payment token to
     swapTargetTokenSymbol: "WETH",
   }
   ```

1. Create a bundle of transactions that includes at least the target NFT transaction.
The object includes the address and price of the NFT and the buyer's wallet address, as in this example:

   ```tsx
   import { ethers } from "ethers"

   // Address of the NFT sale contract
   const NFT_CONTRACT_ADDRESS = "0x77fedfb705c8bac2e03aad2ad8a8fe83e3e20fa1"

   const checkoutTxBundle = ethers.utils.defaultAbiCoder.encode(
     // The Solidity types of the values in the second parameter
     ["address[]", "uint256[]", "bytes[]"],
     [
       [NFT_CONTRACT_ADDRESS],
       [priceOfNft],
       [encodeBuyFunctionCall(USER_WALLET_ADDRESS)],
     ]
   )
   ```

   For more information about bundling transactions, see [Bundling](../bundling).

1. Add the `DappContextProvider` and `RarimoPayButton` components to the page and pass the transaction bundle:

```tsx
import { DappContextProvider, RarimoPayButton } from "@rarimo/react-nft-checkout"

<DappContextProvider
  targetNft={targetNft}
  checkoutTxBundle={checkoutTxBundle}
>
  <RarimoPayButton text="Buy with Rarimo" />
</DappContextProvider>
```

Now when the application loads, the pay button appears on the page, as in this screenshot:

![The pay button](/img/sdk/RarimoPayButton.png)

Here is a complete example:

```tsx
import { useRef } from 'react'
import { ethers } from "ethers"

import { Price, Target } from '@rarimo/nft-checkout'
import { RarimoPayButton, DappContextProvider } from '@rarimo/react-nft-checkout'

const NFT_CONTRACT_ADDRESS = "0x77fedfb705c8bac2e03aad2ad8a8fe83e3e20fa1"
const USER_WALLET_ADDRESS = "0x0000000000000000000000000000000000000000"

export const App = () => {
   // Set the price as 0.1 ETH and convert to gwei
   const priceOfNft = Price.fromRaw('0.01', 18, 'ETH')

   const targetNft = useRef<Target>({
     // Source chain id (Sepolia in this case)
     chainId: 11155111,
     // NFT contract address
     address: NFT_CONTRACT_ADDRESS,
     // Recipient wallet address
     recipient: USER_WALLET_ADDRESS,
     price: priceOfNft,
     // The token to swap the payment token to
     swapTargetTokenSymbol: 'WETH',
   })

   const checkoutTxBundle = ethers.utils.defaultAbiCoder.encode(
    // The Solidity types of the values in the second parameter
    ["address[]", "uint256[]", "bytes[]"],
    [
      [NFT_CONTRACT_ADDRESS],
      [priceOfNft],
      [encodeBuyFunctionCall(USER_WALLET_ADDRESS)],
    ]
  )

  return (
    <div className="app">
      <DappContextProvider
        targetNft={targetNft}
        checkoutTxBundle={checkoutTxBundle}
      >
        <RarimoPayButton />
      </DappContextProvider>
    </div>
  )
}
```

For information about the flow of the components that appear through the checkout process, see [Checkout packages](../sdk/packages-checkout).
