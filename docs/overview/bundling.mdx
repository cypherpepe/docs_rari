---
---

# Bundling

Rarimo's multichain protocol bundles multiple related events into single transactions.
In this way, the protocol simplifies complex, multistep user actions.

Bundling also allows Rarimo to include custom logic with transactions.
Rarimo contracts use this logic to run actions that follow an initial transaction, such as unlocking tokens on other chains and buying NFTs by calling other contracts.

## Example

This high-level example demonstrates how bundling can simplify a user flow:

Alice has an NFT on the Ethereum blockchain.
They want to stake this NFT in a DeFi application on the Polygon blockchain.
Normally, staking an NFT requires multiple transactions:

1. Lock the NFT on the Etherum network.
1. Redeem the NFT on the Polygon network.
1. Stake the NFT in the DeFi application.

Separately, each of these transactions incur gas fees and can fail independently.
This is why we designed Rarimo to bundle transactions on the destination chain.
Our bundled transactions handle these steps efficiently with a single request, incurring a single gas fee and behaving atomically.

## Benefits

- The protocol has efficient gas usage for end users
- Transactions on the destination chain will succeed or fail together
- The development flow can be simplified
- Any address can handle transaction calls and gas fees on behalf of the original requestor

## Limitations

- Transaction bundling works only with EVM networks
- ERC1155 token transfers cannot use bundling

## Implementation

When a transaction locks a token in a Rarimo contract, users can specify additional contracts and methods to call on the destination chain.
The Rarimo contract signs and runs these additional transactions automatically.
Methods that call custom contracts are not overridable, which protects transactions from re-entrancy attacks.

### Bundle Salt

Bundle salt is needed to call custom code securely, it defines an intermediate address from which the Rarimo contract
will send fungible tokens because the Rarimo contract on the destination chain creates a temporary contract on which
will call another contract to buy NFT. Salt is used as part of the Solidity create2 method to create a proxy contract.
So you can use it to determine this proxy contract address. It is needed in rare cases, and you don’t have to determine
it. As salt you should specify random 32 bytes length array encoded into the hex string, there is snipped how to generate it:
```javascript
const salt = ethers.utils.hexlify(ethers.utils.randomBytes(32))
```

### Bundle Data

To create a transaction bundle needed to specify Marketplace contract call and Web3.js and ethers packages must be installed.
We will use `web3.eth.abi.encodeParameters` function to encode all needed parameters into the bytes array.

The first argument will be the Solidity types of parameters that we pass:

NFT contract address (`address[]`) – will be called by Rarimo contract to buy NFT
NFT price (`uint256[]`) –  calculated NFT price token on the destination chain
Encoded function call (`bytes[]`) - encoded NFT contract buy function call

The second argument is a value for upwards types, there is a snippet:

```javascript
const priceOfNft = ethers.utils
  .parseUnits(inputAmount.toString(), TokenB.decimals)
  .toString()

const encodeBuyFunctionCall = (receiver: string) => web3.eth.abi.encodeFunctionCall(
    {
      inputs: [
        { internalType: "address", name: "receiver_", type: "address" },
      ],
      name: "buy",
      outputs: [],
      stateMutability: "payable",
      type: "function",
    },
    [receiver]
)

const bundle = web3.eth.abi.encodeParameters(
  ["address[]", "uint256[]", "bytes[]"],
  [
    [NFT_CONTRACT_ADDRESS],
    [priceOfNft],
    [encodeBuyFunctionCall(USER_WALLET_ADDRESS)],
  ]
)
```
After creating all bundle data we need to call Swap contract method:
```javascript
const salt = ethers.utils.hexlify(ethers.utils.randomBytes(32))

const transaction = await swapContract.swapExactOutputSingleThenBridge(
  amountOut, // 100000000000000000000 === 1*10^18 – one NFT
  approvalAmount,
  inputToken.address, // Token address which we exchange
  outputToken.address, // Token address which we get after exchange
  USER_WALLET_ADDRESS,
  "Sepolia", // Destination network
  true, // isWrapped: is token which we exchange wrapped
  { salt, bundle },
)
```